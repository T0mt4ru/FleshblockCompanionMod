package net.minecraft.world.level.levelgen.feature;

import com.mojang.serialization.Codec;
import net.minecraft.core.BlockPos;
import net.minecraft.util.Mth;
import net.minecraft.util.RandomSource;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.LevelAccessor;
import net.minecraft.world.level.WorldGenLevel;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration;

/**
 * This feature generates part of the icebergs found in frozen oceans.
 * Specifically, it generates tall, triangular prism icebergs, and "donut" or torus shaped icebergs.
 * Other icebergs are generated by the frozen ocean surface builder instead.
 */
public class IcebergFeature extends Feature<BlockStateConfiguration> {
    public IcebergFeature(Codec<BlockStateConfiguration> codec) {
        super(codec);
    }

    /**
     * Places the given feature at the given location.
     * During world generation, features are provided with a 3x3 region of chunks, centered on the chunk being generated, that they can safely generate into.
     *
     * @param context A context object with a reference to the level and the position
     *                the feature is being placed at
     */
    @Override
    public boolean place(FeaturePlaceContext<BlockStateConfiguration> context) {
        BlockPos blockpos = context.origin();
        WorldGenLevel worldgenlevel = context.level();
        blockpos = new BlockPos(blockpos.getX(), context.chunkGenerator().getSeaLevel(), blockpos.getZ());
        RandomSource randomsource = context.random();
        boolean flag = randomsource.nextDouble() > 0.7;
        BlockState blockstate = context.config().state;
        double d0 = randomsource.nextDouble() * 2.0 * Math.PI;
        int i = 11 - randomsource.nextInt(5);
        int j = 3 + randomsource.nextInt(3);
        boolean flag1 = randomsource.nextDouble() > 0.7;
        int k = 11;
        int l = flag1 ? randomsource.nextInt(6) + 6 : randomsource.nextInt(15) + 3;
        if (!flag1 && randomsource.nextDouble() > 0.9) {
            l += randomsource.nextInt(19) + 7;
        }

        int i1 = Math.min(l + randomsource.nextInt(11), 18);
        int j1 = Math.min(l + randomsource.nextInt(7) - randomsource.nextInt(5), 11);
        int k1 = flag1 ? i : 11;

        for (int l1 = -k1; l1 < k1; l1++) {
            for (int i2 = -k1; i2 < k1; i2++) {
                for (int j2 = 0; j2 < l; j2++) {
                    int k2 = flag1 ? this.heightDependentRadiusEllipse(j2, l, j1) : this.heightDependentRadiusRound(randomsource, j2, l, j1);
                    if (flag1 || l1 < k2) {
                        this.generateIcebergBlock(worldgenlevel, randomsource, blockpos, l, l1, j2, i2, k2, k1, flag1, j, d0, flag, blockstate);
                    }
                }
            }
        }

        this.smooth(worldgenlevel, blockpos, j1, l, flag1, i);

        for (int i3 = -k1; i3 < k1; i3++) {
            for (int j3 = -k1; j3 < k1; j3++) {
                for (int k3 = -1; k3 > -i1; k3--) {
                    int l3 = flag1 ? Mth.ceil((float)k1 * (1.0F - (float)Math.pow((double)k3, 2.0) / ((float)i1 * 8.0F))) : k1;
                    int l2 = this.heightDependentRadiusSteep(randomsource, -k3, i1, j1);
                    if (i3 < l2) {
                        this.generateIcebergBlock(worldgenlevel, randomsource, blockpos, i1, i3, k3, j3, l2, l3, flag1, j, d0, flag, blockstate);
                    }
                }
            }
        }

        boolean flag2 = flag1 ? randomsource.nextDouble() > 0.1 : randomsource.nextDouble() > 0.7;
        if (flag2) {
            this.generateCutOut(randomsource, worldgenlevel, j1, l, blockpos, flag1, i, d0, j);
        }

        return true;
    }

    private void generateCutOut(
        RandomSource random,
        LevelAccessor level,
        int majorAxis,
        int height,
        BlockPos pos,
        boolean elliptical,
        int ellipseRadius,
        double angle,
        int minorAxis
    ) {
        int i = random.nextBoolean() ? -1 : 1;
        int j = random.nextBoolean() ? -1 : 1;
        int k = random.nextInt(Math.max(majorAxis / 2 - 2, 1));
        if (random.nextBoolean()) {
            k = majorAxis / 2 + 1 - random.nextInt(Math.max(majorAxis - majorAxis / 2 - 1, 1));
        }

        int l = random.nextInt(Math.max(majorAxis / 2 - 2, 1));
        if (random.nextBoolean()) {
            l = majorAxis / 2 + 1 - random.nextInt(Math.max(majorAxis - majorAxis / 2 - 1, 1));
        }

        if (elliptical) {
            k = l = random.nextInt(Math.max(ellipseRadius - 5, 1));
        }

        BlockPos blockpos = new BlockPos(i * k, 0, j * l);
        double d0 = elliptical ? angle + (Math.PI / 2) : random.nextDouble() * 2.0 * Math.PI;

        for (int i1 = 0; i1 < height - 3; i1++) {
            int j1 = this.heightDependentRadiusRound(random, i1, height, majorAxis);
            this.carve(j1, i1, pos, level, false, d0, blockpos, ellipseRadius, minorAxis);
        }

        for (int k1 = -1; k1 > -height + random.nextInt(5); k1--) {
            int l1 = this.heightDependentRadiusSteep(random, -k1, height, majorAxis);
            this.carve(l1, k1, pos, level, true, d0, blockpos, ellipseRadius, minorAxis);
        }
    }

    private void carve(
        int radius, int localY, BlockPos pos, LevelAccessor level, boolean placeWater, double perpendicularAngle, BlockPos ellipseOrigin, int majorRadius, int minorRadius
    ) {
        int i = radius + 1 + majorRadius / 3;
        int j = Math.min(radius - 3, 3) + minorRadius / 2 - 1;

        for (int k = -i; k < i; k++) {
            for (int l = -i; l < i; l++) {
                double d0 = this.signedDistanceEllipse(k, l, ellipseOrigin, i, j, perpendicularAngle);
                if (d0 < 0.0) {
                    BlockPos blockpos = pos.offset(k, localY, l);
                    BlockState blockstate = level.getBlockState(blockpos);
                    if (isIcebergState(blockstate) || blockstate.is(Blocks.SNOW_BLOCK)) {
                        if (placeWater) {
                            this.setBlock(level, blockpos, Blocks.WATER.defaultBlockState());
                        } else {
                            this.setBlock(level, blockpos, Blocks.AIR.defaultBlockState());
                            this.removeFloatingSnowLayer(level, blockpos);
                        }
                    }
                }
            }
        }
    }

    private void removeFloatingSnowLayer(LevelAccessor level, BlockPos pos) {
        if (level.getBlockState(pos.above()).is(Blocks.SNOW)) {
            this.setBlock(level, pos.above(), Blocks.AIR.defaultBlockState());
        }
    }

    private void generateIcebergBlock(
        LevelAccessor level,
        RandomSource random,
        BlockPos pos,
        int height,
        int localX,
        int localY,
        int localZ,
        int radius,
        int majorRadius,
        boolean elliptical,
        int minorRadius,
        double angle,
        boolean placeSnow,
        BlockState state
    ) {
        double d0 = elliptical
            ? this.signedDistanceEllipse(localX, localZ, BlockPos.ZERO, majorRadius, this.getEllipseC(localY, height, minorRadius), angle)
            : this.signedDistanceCircle(localX, localZ, BlockPos.ZERO, radius, random);
        if (d0 < 0.0) {
            BlockPos blockpos = pos.offset(localX, localY, localZ);
            double d1 = elliptical ? -0.5 : (double)(-6 - random.nextInt(3));
            if (d0 > d1 && random.nextDouble() > 0.9) {
                return;
            }

            this.setIcebergBlock(blockpos, level, random, height - localY, height, elliptical, placeSnow, state);
        }
    }

    private void setIcebergBlock(
        BlockPos pos,
        LevelAccessor level,
        RandomSource random,
        int heightRemaining,
        int height,
        boolean elliptical,
        boolean placeSnow,
        BlockState state
    ) {
        BlockState blockstate = level.getBlockState(pos);
        if (blockstate.isAir() || blockstate.is(Blocks.SNOW_BLOCK) || blockstate.is(Blocks.ICE) || blockstate.is(Blocks.WATER)) {
            boolean flag = !elliptical || random.nextDouble() > 0.05;
            int i = elliptical ? 3 : 2;
            if (placeSnow
                && !blockstate.is(Blocks.WATER)
                && (double)heightRemaining <= (double)random.nextInt(Math.max(1, height / i)) + (double)height * 0.6
                && flag) {
                this.setBlock(level, pos, Blocks.SNOW_BLOCK.defaultBlockState());
            } else {
                this.setBlock(level, pos, state);
            }
        }
    }

    private int getEllipseC(int y, int height, int minorAxis) {
        int i = minorAxis;
        if (y > 0 && height - y <= 3) {
            i = minorAxis - (4 - (height - y));
        }

        return i;
    }

    private double signedDistanceCircle(int x, int z, BlockPos center, int radius, RandomSource random) {
        float f = 10.0F * Mth.clamp(random.nextFloat(), 0.2F, 0.8F) / (float)radius;
        return (double)f
            + Math.pow((double)(x - center.getX()), 2.0)
            + Math.pow((double)(z - center.getZ()), 2.0)
            - Math.pow((double)radius, 2.0);
    }

    /**
     * Given an ellipse defined by the equation {@code (x/a)^2 + (y/b)^2 = 1}, where {@code a} and {@code b} are the semi-major and semi-minor axes respectively, this computes the distance between an arbitrary point and the ellipse.
     * The point (x, y) is within the ellipse if the return value is < 0, outside the ellipse if the return value is > 0 and exactly on the edge of the ellipse if the return value is 0.
     *
     * @param x           The x position of the point to measure the distance to.
     * @param z           The z position of the point to measure distance to.
     * @param center      The center point of the ellipse.
     * @param majorRadius The semi-major axis ({@code a}) of the ellipse.
     * @param minorRadius The semi-minor axis ({@code b}) of the ellipse
     * @param angle       The rotation angle of the ellipse (the angle from the
     *                    positive horizontal axis to the ellipse's major axis).
     */
    private double signedDistanceEllipse(int x, int z, BlockPos center, int majorRadius, int minorRadius, double angle) {
        return Math.pow(
                ((double)(x - center.getX()) * Math.cos(angle) - (double)(z - center.getZ()) * Math.sin(angle)) / (double)majorRadius, 2.0
            )
            + Math.pow(
                ((double)(x - center.getX()) * Math.sin(angle) + (double)(z - center.getZ()) * Math.cos(angle)) / (double)minorRadius, 2.0
            )
            - 1.0;
    }

    private int heightDependentRadiusRound(RandomSource random, int y, int height, int majorAxis) {
        float f = 3.5F - random.nextFloat();
        float f1 = (1.0F - (float)Math.pow((double)y, 2.0) / ((float)height * f)) * (float)majorAxis;
        if (height > 15 + random.nextInt(5)) {
            int i = y < 3 + random.nextInt(6) ? y / 2 : y;
            f1 = (1.0F - (float)i / ((float)height * f * 0.4F)) * (float)majorAxis;
        }

        return Mth.ceil(f1 / 2.0F);
    }

    /**
     * Given a horizontal projection of an iceberg, defines the three-dimensional extrusion by defining a radius at any given y value.
     * The radius curve is a parabolic function, resulting in more rounded iceberg peaks.
     *
     * @param y         The y value to calculate a radius at.
     * @param height    The maximum height of the iceberg.
     * @param maxRadius The maximum radius of the iceberg, at the horizontal.
     */
    private int heightDependentRadiusEllipse(int y, int height, int maxRadius) {
        float f = 1.0F;
        float f1 = (1.0F - (float)Math.pow((double)y, 2.0) / ((float)height * 1.0F)) * (float)maxRadius;
        return Mth.ceil(f1 / 2.0F);
    }

    /**
     * Given a horizontal projection of an iceberg, defines the three-dimensional extrusion by defining a radius at any given y value.
     * The radius curve is a linear function, with a slope that is both dependent on the {@code majorAxis} and randomly varies, which results in steep conical icebergs.
     *
     * @param random    A random to use to vary the slope of the falloff curve.
     * @param y         The y value to calculate a radius at.
     * @param height    The maximum height of the iceberg.
     * @param maxRadius The maximum radius radius of the iceberg, at the horizontal.
     */
    private int heightDependentRadiusSteep(RandomSource random, int y, int height, int maxRadius) {
        float f = 1.0F + random.nextFloat() / 2.0F;
        float f1 = (1.0F - (float)y / ((float)height * f)) * (float)maxRadius;
        return Mth.ceil(f1 / 2.0F);
    }

    private static boolean isIcebergState(BlockState state) {
        return state.is(Blocks.PACKED_ICE) || state.is(Blocks.SNOW_BLOCK) || state.is(Blocks.BLUE_ICE);
    }

    private boolean belowIsAir(BlockGetter level, BlockPos pos) {
        return level.getBlockState(pos.below()).isAir();
    }

    /**
     * Smooths out an iceberg by removing blocks which either have air below, or non-iceberg blocks on three or more horizontal sides, with air.
     */
    private void smooth(LevelAccessor level, BlockPos pos, int majorRadius, int height, boolean elliptical, int minorRadius) {
        int i = elliptical ? minorRadius : majorRadius / 2;

        for (int j = -i; j <= i; j++) {
            for (int k = -i; k <= i; k++) {
                for (int l = 0; l <= height; l++) {
                    BlockPos blockpos = pos.offset(j, l, k);
                    BlockState blockstate = level.getBlockState(blockpos);
                    if (isIcebergState(blockstate) || blockstate.is(Blocks.SNOW)) {
                        if (this.belowIsAir(level, blockpos)) {
                            this.setBlock(level, blockpos, Blocks.AIR.defaultBlockState());
                            this.setBlock(level, blockpos.above(), Blocks.AIR.defaultBlockState());
                        } else if (isIcebergState(blockstate)) {
                            BlockState[] ablockstate = new BlockState[]{
                                level.getBlockState(blockpos.west()),
                                level.getBlockState(blockpos.east()),
                                level.getBlockState(blockpos.north()),
                                level.getBlockState(blockpos.south())
                            };
                            int i1 = 0;

                            for (BlockState blockstate1 : ablockstate) {
                                if (!isIcebergState(blockstate1)) {
                                    i1++;
                                }
                            }

                            if (i1 >= 3) {
                                this.setBlock(level, blockpos, Blocks.AIR.defaultBlockState());
                            }
                        }
                    }
                }
            }
        }
    }
}
